/*
핵심: 효율성 테스트를 통과하기 위해서는 동적 프로그래밍으로 접근해야한다

접근: (1, 1) 위치에서부터 시작해서 그 꼭짓점을 포함해서 그릴 수 있는 가장 큰 정사각형의
한 변의 길이를 저장한다. 이를 구하는 방법은 이 꼭짓점 기준 왼쪽, 위쪽, 왼-위쪽 꼭짓점의
최솟값에 1을 더하는 것이다. (이 꼭짓점을 포함하면서 한 변의 길이가 1보다 크기 위해서는
위에서 언급한 점들을 반드시 포함해야하기 때문)

세부 진행
1. 가로 길이 혹은 세로 길이가 1인 보드가 주어지면 가장 큰 정사각형의 한 변의 길이는 1이다.
  따라서 모든 값 중 최댓값(0 혹은 1)을 반환한다. (루프를 (1, 1)부터 시작하기 위함)
2. 최대 변의 길이를 저장할 보드를 원래 보드를 복사해서 생성한다.
3. (1, 1)에서 마지막 꼭짓점까지 반복하는 이중 반복문을 생성한다.
4. 꼭짓점의 값이 1이면 해당 꼭짓점으로는 정사각형을 그릴 수 있는 것이다.
5. 위의 경우 왼쪽, 위쪽, 왼-위쪽의 최솟값 + 1을 현재 꼭짓점의 값으로 할당한다.
6. 반복문 밖에 선언한 max 값과 비교해서 현재 max값과 새 꼭짓점 값 중 큰 것으로 할당한다.
7. 이렇게 반복문을 종료한 후 max 값은 그릴 수 있는 가장 큰 정사각형의 한 변의 길이이다.
8. max의 제곱(넓이)를 반환한다.

참고자료: https://onlydev.tistory.com/65
*/

function solution(board) {
  // 1
  if (board.length <= 1 || board[0].length <= 1)
    return Math.max(...board.flat());

  // 2
  const area = [...board];
  let max = 0;

  // 3
  for (let i = 1; i < board.length; i++) {
    for (let j = 1; j < board[0].length; j++) {
      // 4, 5
      if (area[i][j] === 1) {
        const min = Math.min(
          area[i][j - 1],
          area[i - 1][j],
          area[i - 1][j - 1],
        );
        area[i][j] = min + 1;
        max = Math.max(max, area[i][j]); // 6
      }
    }
  }

  // 7, 8
  return max ** 2;
}
